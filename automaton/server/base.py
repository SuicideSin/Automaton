#!/usr/bin/env python

import re
import sys
import uuid
import inspect
import threading

import automaton.plugins
import automaton.lib.utils as utils
import automaton.lib.logger as logger
import automaton.lib.registrar as registrar
import automaton.lib.exceptions as exceptions
import automaton.lib.platformdata as platformdata
from automaton.lib.clientmanager import ClientManager
import automaton.lib.input_sanitizer as input_sanitizer
from automaton.lib.plugin import PluginInterface, UnsuccessfulExecution


class AutomatonServer(object):

  class __loaded_plugin(object):
    def __init__(self, plugin):
      self.obj = plugin
      self.lock = threading.Lock()

  def __init__(self, withgui=False, useinterpreter=False):
    self.needsgui = withgui

    # The exceptions generated by the server in response to erroneous client
    # behavior. Can be overridden in subclasses of the AutomatonServer.
    self.exceptions = exceptions

    self.registrar = registrar.Registrar()
    self.sanitizer = input_sanitizer.InputSanitizer(self.registrar)

    # A dictionary mapping clientids to registered plugins
    self.clientmanager = ClientManager()

    # Update __init__.py in the automaton package when a new plugin is added
    self.loadedPlugins = {}
    for plugin in automaton.plugins.__all__:
      try:
        self.enablePlugin(plugin)
      except Exception as e:
        logger.log("Error loading module {0}.".format(plugin), e)

    if useinterpreter:
      import automaton.lib.interpreter as interpreter
      self.interpreter = interpreter.Interpreter(self.registrar)
    else:
      self.interpreter = None

  """ Start plugin initialization section """
  def enablePlugin(self, name):
    # Imports the plugin module
    module = __import__('automaton.plugins.{0}'.format(name), fromlist=[name])
    # Either no platform restriction is provided, or the platform is
    # in the restriction set
    if not hasattr(module, 'platform') or (platformdata.platform in
                                                         module.platform()):
      # Searches through the module for classes that implement the
      # automaton.lib.plugin.PluginInterface class
      # If there is more than one class in a file, only the first is
      # instantiated.
      classes = inspect.getmembers(module,
          lambda obj: inspect.isclass(obj) and
                      issubclass(obj, PluginInterface))
      if len(classes) == 0:
        raise ImportError("No class in {0} implements "
                "automaton.lib.plugins.PluginInterface".format(name))
      cls = classes[0][1](self.registrar)
      self.loadedPlugins[name] = self.__loaded_plugin(cls)

  def disablePlugin(self, name):
    if hasattr(self.loadedPlugins[name], "disable"):
      self.loadedPlugins[name].disable()
    del self.loadedPlugins[name]

  def reloadPlugin(self, name):
    if name in self.loadedPlugins:
      self.loadedPlugins[name].lock.acquire()
      try:
        cmd = reload(__import__('automaton.plugins.{0}'.format(name),
                                fromlist=[name]))
        self.loadedPlugins[name].obj = getattr(cmd, name)()
        logger.log("Plugin {0} has been successfully reloaded.".format(name))
      except Exception as e:
        print e
        self.disablePlugin(name)
        error = ("Exception encountered reloading {0}. "
                  "Plugin disabled.".format(name))
        logger.log(name)
      finally:
        self.loadedPlugins[name].lock.release()

  """ Start public server functions """
  # Registers a client service with the server. Calculates a UUID that will
  # identify which plugins are loaded for each client service
  # Arguments: none
  # Return value: string
  # Throws: none
  def registerClient(self, appname=None):
    ident = str(uuid.uuid1())
    while ident in self.clientmanager.registeredclients:
      ident = str(uuid.uuid1())
    if appname is not None:
      ident = re.sub('[\W_]+', '', appname) + '-' + ident
    logger.log("Registering client {0}".format(ident))
    self.clientmanager.add_client(ident)
    return ident

  # Unregisters a client service from the server. Any further use of its
  # clientid will result in a ServiceNotRegisteredError
  # Arguments: clientid:string - id associated with a registered service
  # Return value: void
  # Throws: ClientNotRegisteredError
  def unregisterClient(self, clientid):
    if clientid not in self.clientmanager.registeredclients:
      raise self.exceptions.ClientNotRegisteredError()

    logger.log("Unregistering client {0}".format(clientid))
    del self.clientmanager.registeredclients[clientid]

  # Registers a service for use by a client.
  # Arguments: clientid:string, name:string
  # Return value: void
  # Throws: ClientNotRegisteredError, ServiceNotLoadedException
  def allowService(self, clientid, name):
    name = name.lower()
    if clientid not in self.clientmanager.registeredclients:
      raise self.exceptions.ClientNotRegisteredError()
    if name not in self.registrar.services:
      raise self.exceptions.ServiceNotProvidedError(name)

    if name not in self.clientmanager.registeredclients[clientid].plugins:
      logger.log("Adding service {0} for client {1}".format(name, clientid))
      self.clientmanager.registeredclients[clientid].plugins.add(name)

  # Unregisters a service from being used in a client.
  # Arguments: clientid:string, name:string
  # Return value: void
  # Throws: ClientNotRegisteredError, ServiceNotRegisteredError
  def disallowService(self, clientid, name):
    name = name.lower()
    if clientid not in self.clientmanager.registeredclients:
      raise self.exceptions.ClientNotRegisteredError()
    if name not in self.clientmanager.registeredclients[clientid].plugins:
      raise self.exceptions.ServiceNotRegisteredError(name)

    logger.log("Removing service {0} for client {1}".format(name, clientid))
    self.clientmanager.registeredclients[clientid].plugins.remove(name)

  def allowAllServices(self, clientid):
    logger.log("Allowing all services for client {0}".format(clientid))
    self.clientmanager.registeredclients[clientid].plugins = set(
                                              self.registrar.services.keys())

  def disallowAllServices(self, clientid):
    logger.log("Removing all services for client {0}".format(clientid))
    self.clientmanager.registeredclients[clientid].plugins = set()

  # Uses the interpreter to translate the raw (arbitrary) text into
  # a command:arguments pair that is then executed like normal
  # Arguments: clientid:string, raw:string
  # Return value: string
  # Throws: ClientNotRegisteredError, ServiceNotRegisteredError,
  #         UnknownActionException
  def interpret(self, clientid, raw):
    if clientid not in self.clientmanager.registeredclients:
      raise self.exceptions.ClientNotRegisteredError()
    if self.interpreter is not None:
      command, args = self.interpreter.interpret(raw)
    else:
      command, sep, args = raw.partition(" ")
      
    if command is None:
      return "Execution failed: could not find command."
      
    if (command.lower() not in
          self.clientmanager.registeredclients[clientid].plugins):
      raise self.exceptions.ServiceNotRegisteredError(command)

    #args = self.sanitizer.alias(args)
    #args = self.sanitizer.sanitize(args)

    try:
      output = self.registrar.request_service(command, **args)
    except UnsuccessfulExecution as e:
      output = "Execution failed: " + str(e)
    self.sanitizer.set_prev_alias(output)
    self.clientmanager.registeredclients[clientid].history.append(raw)
    print "History: ", self.clientmanager.registeredclients[clientid].history
    return output

  # Tests if the specified service is provided or not.
  # Querying is possible even when unregistered
  # Arguments: name:string
  # Return value: bool
  # Throws: none
  def isService(self, name):
    return name.lower() in self.registrar.services

  # Returns a set of strings containing all loaded plugins
  # Querying is possible even when unregistered
  # Arguments: none
  # Return value: set<string>
  # Throws: none
  def getAvailableServices(self):
    return self.registrar.services.keys()

  # Returns the contents of the specified plugin's help() method
  # Replaces the complicated help "command"
  # Arguments: name:string
  # Return value: string
  # Throws ServiceNotProvidedError
  def serviceUsage(self, name):
    name = name.lower()
    if name not in self.registrar.services:
      raise self.exceptions.ServiceNotProvidedError(name)
    return self.registrar.services[name].usage

  """ Start server initialization functions """
  # Ensures that any networking is done in a separate thread from UI
  def start(self):
    if hasattr(self, "_start"):
      # Spawn a second thread for the _start method
      if self.needsgui:
        thread = threading.Thread(target=self._start)
        thread.setDaemon(True)
        thread.start()
        self.load_gui()
      else:
        self._start()
    # If there's no _start method defined, we've got to load the gui
    # or else there will be no way to communicate with the application.
    else:
      self.load_gui()

  def load_gui(self):
    try:
      import gtk
    except ImportError:
      logger.log("gtk toolkit not present, so no graphical "
                  "user interface will be available.")
    import automaton.lib.ui as ui
    ui.StatusIcon(self)
    gtk.gdk.threads_init()
    gtk.main()
