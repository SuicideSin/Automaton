#!/usr/bin/env python

import sys
import uuid
import platform
import Automaton
import logger
import Interpreter
import Exceptions

class AutomatonServer:
  def __init__(self):
    # The exceptions generated by the server in response to eroneous client
    # behavior. Can be overridden in subclasses of the AutomatonServer.
    self.Exceptions = Exceptions
    # A dictionary mapping serviceids to registered scripts
    self.registeredServices = {}
    # Update __init__.py in the Automaton package when a new script is added
    self.loadedScripts = {}
    for script in Automaton.__all__:
      try:
        # Imports the command module
        cmd = __import__('Automaton.%s' % script, globals(), locals(), [script])
        # Extracts the class from the command module
        # Class must have same name as module
        cmdcls = getattr(cmd, script)()
        # Either no platform restriction is provided, or the platform is
        # in the restriction set
        if not hasattr(cmdcls, 'platform') or self.__getPlatform() in cmdcls.platform():
          self.loadedScripts[script] = cmdcls
      except (Exceptions.ModuleLoadException, ImportError, AttributeError):
        print "Error loading module %s." % script
        

  # Registers a client service with the server. Calculates a UUID that will
  # identify which scripts are loaded for each client service
  # Arguments: none
  # Return value: string
  # Throws: none
  def registerService(self):
    id = str(uuid.uuid1())
    while self.registeredServices.has_key(id):
      print id
      id = str(uuid.uuid1())
    logger.log("Registering service %s" % id)
    self.registeredServices[id]=set()
    return id

  # Unregisters a client service from the server. Any further use of its serviceid will
  # result in a ServiceNotRegisteredException
  # Arguments: serviceid:string - id associated with a registered service
  # Return value: void
  # Throws: ServiceNotRegisteredException
  def unregisterService(self, serviceid):
    if serviceid not in self.registeredServices:
      raise self.Exceptions.ServiceNotRegisteredException()

    logger.log("Unregistering service %s" % serviceid)
    del self.registeredServices[serviceid]
    return

  # Registers a script for use by a client service.
  # Arguments: serviceid:string, scriptname:string
  # Return value: void
  # Throws: ServiceNotRegisteredException, ScriptNotLoadedException
  def registerScript(self, serviceid, scriptname):
    if serviceid not in self.registeredServices:
      raise self.Exceptions.ServiceNotRegisteredException()
    if scriptname not in self.loadedScripts.keys():
      raise self.Exceptions.ScriptNotLoadedException(scriptname)

    if scriptname not in self.registeredServices[serviceid]:
      logger.log("Adding script %s for service %s" % (scriptname, serviceid))
      self.registeredServices[serviceid].add(scriptname)
    return

  # Unregisters a script from a client service.
  # Arguments: serviceid:string, scriptname:string
  # Return value: void
  # Throws: ServiceNotRegisteredException, ScriptNotLoadedException
  def unregisterScript(self, serviceid, scriptname):
    if serviceid not in self.registeredServices:
      raise self.Exceptions.ServiceNotRegisteredException()
    if scriptname not in self.registeredServices[serviceid]:
      raise self.Exceptions.ScriptNotRegisteredException(scriptname)

    logger.log("Removing script %s for service %s" % (scriptname, serviceid))
    self.registeredServices[serviceid].remove(scriptname)
    return

  # Executes the provided script with any associated arguments.
  # Arguments: serviceid:string, scriptname:string, arguments:string
  # Return value: string
  # Throws: ServiceNotRegisteredException, ScriptNotRegisteredException
  def execute(self, serviceid, scriptname, arguments):
    if serviceid not in self.registeredServices:
      raise self.Exceptions.ServiceNotRegisteredException()
    if scriptname not in self.registeredServices[serviceid]:
      raise self.Exceptions.ScriptNotRegisteredException(scriptname)

    # Executes module from the pool of globally imported modules.
    # Safe because only legal scripts are allowed to be registered.
    return self.loadedScripts[scriptname].execute(arguments)

  # Uses the interpreter to translate the raw (arbitrary) text into
  # a command:arguments pair that is then executed like normal
  # Arguments: serviceid:string, raw:string
  # Return value: string
  # Throws: ServiceNotRegisteredException, ScriptNotRegisteredException,
  #         UnknownActionException
  def interpret(self, serviceid, raw):
    if serviceid not in self.registeredServices:
      raise self.Exceptions.ServiceNotRegisteredException()
    command, args = Interpreter.interpret(raw, [self.loadedScripts[x] for x in self.registeredServices[serviceid]])
    return self.execute(serviceid, command, args)

  # Tests if the specified script is loaded or not.
  # Querying is possible even when unregistered
  # Arguments: scriptname:string
  # Return value: bool
  # Throws: none
  def isScript(self, scriptname):
    return scriptname in self.loadedScripts.keys()

  # Returns a set of strings containing all loaded scripts
  # Querying is possible even when unregistered
  # Arguments: none
  # Return value: set<string>
  # Throws: none
  def getAvailableScripts(self):
    return self.loadedScripts.keys()

  # Returns the contents of the specified script's help() method
  # Replaces the complicated help "command"
  # Arguments: scriptname:string
  # Return value: string
  # Throws ScriptNotLoadedException
  def scriptUsage(self, scriptname):
    if scriptname not in self.loadedScripts.keys():
      raise self.Exceptions.ScriptNotLoadedException(scriptname)
    return self.loadedScripts[scriptname].help()

  def call(self, scriptname, args):
    if scriptname not in self.loadedScripts.keys():
      return ''
    return self.loadedScripts[scriptname].execute(args)

  def __getPlatform(self):
    if platform.system().lower().startswith('windows'):
      return 'windows'
    elif platform.system().lower().startswith('darwin'):
      return 'mac'
    else:
      return 'linux'

