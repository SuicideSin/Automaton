#!/usr/bin/env python

import re
import sys
import uuid
import inspect
import threading
import Automaton.plugins
import Automaton.lib.utils as utils
import Automaton.lib.logger as logger
import Automaton.lib.platformdata as platformdata
import Automaton.lib.registrar as registrar
import Automaton.lib.exceptions as exceptions
from Automaton.lib.plugin import PluginInterface
import Automaton.lib.input_sanitizer as input_sanitizer

class AutomatonServer(object):

  class __loaded_plugin(object):
    def __init__(self, plugin):
      self.obj = plugin
      self.lock = threading.Lock()

  def __init__(self, withgui = False, useinterpreter = False):

    self.needsgui = withgui

    # The exceptions generated by the server in response to erroneous client
    # behavior. Can be overridden in subclasses of the AutomatonServer.
    self.exceptions = exceptions

    self.registrar = registrar.Registrar()
    self.sanitizer = input_sanitizer.InputSanitizer(self.registrar)

    # A dictionary mapping clientids to registered plugins
    self.registeredClients = {}

    # Update __init__.py in the Automaton package when a new plugin is added
    self.loadedPlugins = {}
    for plugin in Automaton.plugins.__all__:
      try:
        self.enablePlugin(plugin)
      except Exception as e:
        logger.log("Error loading module {0}.".format(plugin), e)

    if useinterpreter:
      import interpreter
      self.interpreter = interpreter.Interpreter(self.registrar)
    else:
      self.interpreter = None


  """ Start plugin initialization section """

  def enablePlugin(self, name):
    # Imports the plugin module
    module = __import__('Automaton.plugins.{0}'.format(name), fromlist= [name])
    # Either no platform restriction is provided, or the platform is
    # in the restriction set
    if not hasattr(module, 'platform') or (platformdata.platform in
                                                         module.platform()):
      # Searches through the module for classes that implement the
      # Automaton.lib.plugin.PluginInterface class
      # If there is more than one class in a file, only the first is
      # instantiated.
      classes = inspect.getmembers(module,
          lambda obj: inspect.isclass(obj) and issubclass(obj, PluginInterface))
      if len(classes) == 0:
        raise ImportError("No class in {0} implements "
                "Automaton.lib.plugins.PluginInterface".format(name))
      cls = classes[0][1](self.registrar)
      self.loadedPlugins[name] = self.__loaded_plugin(cls)

  def disablePlugin(self, name):
    if hasattr(self.loadedPlugins[name], "disable"):
      self.loadedPlugins[name].disable()
    del self.loadedPlugins[name]

  def reloadPlugin(self, name):
    if name in self.loadedPlugins:
      self.loadedPlugins[name].lock.acquire()
      try:
        cmd = reload(__import__('Automaton.plugins.{0}'.format(name), fromlist = [name]))
        self.loadedPlugins[name].obj = getattr(cmd, name)()
        logger.log("Plugin {0} has been successfully reloaded.".format(name))
      except Exception as e:
        print e
        self.disablePlugin(name)
        error = "Exception encountered reloading {0}. Plugin disabled.".format(name)
        logger.log(name)
      finally:
        self.loadedPlugins[name].lock.release()


  """ Start public server functions """

  # Registers a client service with the server. Calculates a UUID that will
  # identify which plugins are loaded for each client service
  # Arguments: none
  # Return value: string
  # Throws: none
  def registerClient(self, appname = None):
    id = str(uuid.uuid1())
    while id in self.registeredClients:
      id = str(uuid.uuid1())
    if appname is not None:
      id = re.sub('[\W_]+', '', appname) + '-' + id
    logger.log("Registering client {0}".format(id))
    self.registeredClients[id]=set()
    return id

  # Unregisters a client service from the server. Any further use of its clientid will
  # result in a ServiceNotRegisteredError
  # Arguments: clientid:string - id associated with a registered service
  # Return value: void
  # Throws: ClientNotRegisteredError
  def unregisterClient(self, clientid):
    if clientid not in self.registeredClients:
      raise self.exceptions.ClientNotRegisteredError()

    logger.log("Unregistering client {0}".format(clientid))
    del self.registeredClients[clientid]

  # Registers a service for use by a client.
  # Arguments: clientid:string, name:string
  # Return value: void
  # Throws: ClientNotRegisteredError, ServiceNotLoadedException
  def allowService(self, clientid, name):
    name = name.lower()
    if clientid not in self.registeredClients:
      raise self.exceptions.ClientNotRegisteredError()
    if name not in self.registrar.services:
      raise self.exceptions.ServiceNotProvidedError(name)

    if name not in self.registeredClients[clientid]:
      logger.log("Adding service {0} for client {1}".format(name, clientid))
      self.registeredClients[clientid].add(name)

  # Unregisters a service from being used in a client.
  # Arguments: clientid:string, name:string
  # Return value: void
  # Throws: ClientNotRegisteredError, ServiceNotRegisteredError
  def disallowService(self, clientid, name):
    name = name.lower()
    if clientid not in self.registeredClients:
      raise self.exceptions.ClientNotRegisteredError()
    if name not in self.registeredClients[clientid]:
      raise self.exceptions.ServiceNotRegisteredError(name)

    logger.log("Removing service {0} for client {1}".format(name, clientid))
    self.registeredClients[clientid].remove(name)


  def allowAllServices(self, clientid):
    logger.log("Allowing all services for client {0}".format(clientid))
    self.registeredClients[clientid] = set(self.registrar.services.keys())


  def disallowAllServices(self, clientid):
    logger.log("Removing all services for client {0}".format(clientid))
    self.registeredClients[clientid] = set()


  # Uses the interpreter to translate the raw (arbitrary) text into
  # a command:arguments pair that is then executed like normal
  # Arguments: clientid:string, raw:string
  # Return value: string
  # Throws: ClientNotRegisteredError, ServiceNotRegisteredError,
  #         UnknownActionException
  def interpret(self, clientid, raw):
    if clientid not in self.registeredClients:
      raise self.exceptions.ClientNotRegisteredError()
    if self.interpreter is not None:
      command, args = self.interpreter.interpret(raw)
    else:
      command, sep, args = raw.partition(" ") # split on the first space
    if command.lower() not in self.registeredClients[clientid]:
      raise self.exceptions.ServiceNotRegisteredError(command)

    args = self.sanitizer.alias(args)
    args = self.sanitizer.sanitize(args)

    output = self.registrar.request_service(command, args)
    self.sanitizer.set_prev_alias(output)
    return output
  

  # Tests if the specified service is provided or not.
  # Querying is possible even when unregistered
  # Arguments: name:string
  # Return value: bool
  # Throws: none
  def isService(self, name):
    return name.lower() in self.registrar.services

  # Returns a set of strings containing all loaded plugins
  # Querying is possible even when unregistered
  # Arguments: none
  # Return value: set<string>
  # Throws: none
  def getAvailableServices(self):
    return self.registrar.services.keys()

  # Returns the contents of the specified plugin's help() method
  # Replaces the complicated help "command"
  # Arguments: name:string
  # Return value: string
  # Throws ServiceNotProvidedError
  def serviceUsage(self, name):
    name = name.lower()
    if name not in self.registrar.services:
      raise self.exceptions.ServiceNotProvidedError(name)
    return self.registrar.services[name].usage


  """ Start server initialization functions """

  # No initialization done for the local server, can be overridden in subclasses
  def initialize(self):
    pass

  # Ensures that any networking is done in a separate thread from 
  def start(self):
    if hasattr(self, "_start"):
      # Spawn a second thread for the _start method
      if self.needsgui:
        thread = threading.Thread(target = self._start)
        thread.setDaemon(True)
        thread.start()
        self.load_gui()
      else:
        self._start()
    # If there's no _start method defined, we've got to load the gui
    # or else there will be no way to communicate with the application.
    else:
      self.load_gui()

  def load_gui(self):
    try:
      import gtk
      import ui
      ui.StatusIcon(self)
      gtk.gdk.threads_init()
      gtk.main()
    except ImportError:
      logger.log("gtk toolkit not present, so no graphical user interface will "
             "be available.")
