#!/usr/bin/env python

import re
import sys
import uuid
import utils
import logger
import platform
import threading
import exceptions
import interpreter
import platformdata
import input_sanitizer
import Automaton.plugins

class AutomatonServer(object):

  class __loaded_plugin(object):
    def __init__(self, plugin):
      self.obj = plugin
      self.lock = threading.Lock()

  def __init__(self, withgui = False):

    self.needsgui = withgui

    # The exceptions generated by the server in response to erroneous client
    # behavior. Can be overridden in subclasses of the AutomatonServer.
    self.exceptions = exceptions

    # Set up the sanitizer and allow it to "call" any plugin that we've loaded
    self.sanitizer = input_sanitizer.InputSanitizer()
    self.sanitizer.call = self.call

    # A dictionary mapping serviceids to registered plugins
    self.registeredServices = {}

    # Update __init__.py in the Automaton package when a new plugin is added
    self.loadedPlugins = {}
    for plugin in Automaton.plugins.__all__:
      try:
        self.enablePlugin(plugin)
      except Exception, e:
        logger.log("Error loading module %s." % plugin, e)

    self.interpreter = interpreter.Interpreter(self.loadedPlugins.values())

  def enablePlugin(self, name):
    # Imports the plugin module
    cmd = __import__('Automaton.plugins.%s' % name, fromlist= [name])
    # Extracts the class from the plugin module
    # Class must have same name as module
    # Acts like:
    #  from Automaton.plugins import plugin
    #  cmdcls = plugin.plugin() <-object created
    cmdcls = getattr(cmd, name)()
    # Lets plugins call other plugins
    cmdcls.call = self.call
    # Either no platform restriction is provided, or the platform is
    # in the restriction set
    if not hasattr(cmdcls, 'platform') or (platformdata.platform in
                                                         cmdcls.platform()):
      # Plugin, lock tuple
      self.loadedPlugins[name] = self.__loaded_plugin(cmdcls)

  def disablePlugin(self, name):
    del self.loadedPlugins[name]

  def reloadPlugin(self, name):
    if name in self.loadedPlugins:
      self.loadedPlugins[name].lock.acquire()
      try:
        cmd = reload(__import__('Automaton.plugins.%s' % name, fromlist = [name]))
        self.loadedPlugins[name].obj = getattr(cmd, name)()
        logger.log("Plugin %s has been successfully reloaded." % name)
      except Exception, e:
        print e
        self.disablePlugin(name)
        error = "Exception encountered reloading %s. Plugin disabled." % name
        logger.log(name)
      finally:
        self.loadedPlugins[name].lock.release()

  # Registers a client service with the server. Calculates a UUID that will
  # identify which plugins are loaded for each client service
  # Arguments: none
  # Return value: string
  # Throws: none
  def registerService(self, appname = None):
    id = str(uuid.uuid1())
    while id in self.registeredServices:
      id = str(uuid.uuid1())
    if appname is not None:
      id = re.sub('[\W_]+', '', appname) + '-' + id
    logger.log("Registering service %s" % id)
    self.registeredServices[id]=set()
    return id

  # Unregisters a client service from the server. Any further use of its serviceid will
  # result in a ServiceNotRegisteredException
  # Arguments: serviceid:string - id associated with a registered service
  # Return value: void
  # Throws: ServiceNotRegisteredException
  def unregisterService(self, serviceid):
    if serviceid not in self.registeredServices:
      raise self.exceptions.ServiceNotRegisteredException()

    logger.log("Unregistering service %s" % serviceid)
    del self.registeredServices[serviceid]
    return

  # Registers a plugin for use by a client service.
  # Arguments: serviceid:string, name:string
  # Return value: void
  # Throws: ServiceNotRegisteredException, PluginNotLoadedException
  def registerPlugin(self, serviceid, name):
    if serviceid not in self.registeredServices:
      raise self.exceptions.ServiceNotRegisteredException()
    if name not in self.loadedPlugins.keys():
      raise self.exceptions.PluginNotLoadedException(name)

    if name not in self.registeredServices[serviceid]:
      logger.log("Adding plugin %s for service %s" % (name, serviceid))
      self.registeredServices[serviceid].add(name)
    return

  # Unregisters a plugin from a client service.
  # Arguments: serviceid:string, name:string
  # Return value: void
  # Throws: ServiceNotRegisteredException, PluginNotRegisteredException
  def unregisterPlugin(self, serviceid, name):
    if serviceid not in self.registeredServices:
      raise self.exceptions.ServiceNotRegisteredException()
    if name not in self.registeredServices[serviceid]:
      raise self.exceptions.PluginNotRegisteredException(name)

    logger.log("Removing plugin %s for service %s" % (name, serviceid))
    self.registeredServices[serviceid].remove(name)
    return

  # Backend "execution" code - no service id is necessary because
  # it can only be called directly from plugins
  def call(self, name, arguments):
    if name not in self.loadedPlugins:
      raise self.exceptions.PluginNotLoadedException(name)

    # Executes module from the pool of globally imported modules.
    # Safe because only legal plugins are allowed to be registered.
    self.loadedPlugins[name].lock.acquire()
    try:
      if self.loadedPlugins[name].obj is None:
        return "Plugin is currently unavailable. Please fix plugin and reload."
      arguments = self.sanitizer.sanitize(arguments)
      try:
        retval = self.loadedPlugins[name].obj.execute(arguments)
      finally:
        self.loadedPlugins[name].lock.release()
    except Exception, e:
      retval = "Exception encountered executing plugin %s." % name
      logger.log("%s\n%s" % (retval, e))
    self.sanitizer.set_prev(retval)
    return retval.strip()

  # Executes the provided plugin with any associated arguments.
  # Arguments: serviceid:string, name:string, arguments:string
  # Return value: string
  # Throws: ServiceNotRegisteredException, PluginNotRegisteredException
  def execute(self, serviceid, name, arguments):
    if serviceid not in self.registeredServices:
      raise self.exceptions.ServiceNotRegisteredException()
    if name not in self.registeredServices[serviceid]:
      raise self.exceptions.PluginNotRegisteredException(name)

    return self.call(name, arguments)

  # Uses the interpreter to translate the raw (arbitrary) text into
  # a command:arguments pair that is then executed like normal
  # Arguments: serviceid:string, raw:string
  # Return value: string
  # Throws: ServiceNotRegisteredException, PluginNotRegisteredException,
  #         UnknownActionException
  def interpret(self, serviceid, raw):
    if serviceid not in self.registeredServices:
      raise self.exceptions.ServiceNotRegisteredException()
    command, args = self.interpreter.interpret(raw)
    return self.execute(serviceid, command, args)

  # Tests if the specified plugin is loaded or not.
  # Querying is possible even when unregistered
  # Arguments: name:string
  # Return value: bool
  # Throws: none
  def isPlugin(self, name):
    return name in self.loadedPlugins.keys()

  # Returns a set of strings containing all loaded plugins
  # Querying is possible even when unregistered
  # Arguments: none
  # Return value: set<string>
  # Throws: none
  def getAvailablePlugins(self):
    return self.loadedPlugins.keys()

  # Returns the contents of the specified plugin's help() method
  # Replaces the complicated help "command"
  # Arguments: name:string
  # Return value: string
  # Throws PluginNotLoadedException
  def pluginUsage(self, name):
    if name not in self.loadedPlugins.keys():
      raise self.exceptions.PluginNotLoadedException(name)
    return self.loadedPlugins[name].obj.help()

  # No initialization done for the local server, can be overridden in subclasses
  def initialize(self):
    pass

  # Ensures that any networking is done in a separate thread from 
  def start(self):
    if hasattr(self, "_start"):
      # Spawn a second thread for the _start method
      if self.needsgui:
        thread = threading.Thread(target = self._start)
        thread.setDaemon(True)
        thread.start()
        self.load_gui()
      else:
        self._start()
    # If there's no _start method defined, we've got to load the gui
    # or else there will be no way to communicate with the application.
    else:
      self.load_gui()

  def load_gui(self):
    try:
      import gtk
      import ui
      ui.StatusIcon(self)
      gtk.gdk.threads_init()
      gtk.main()
    except ImportError:
      logger.log("gtk toolkit not present, so no graphical user interface will "
             "be available.")
