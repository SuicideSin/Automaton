#!/usr/bin/env python

import sys
import uuid
import Automaton
import logger
import Interpreter
import Exceptions

class AutomatonServer:
  def __init__(self):
    # The exceptions generated by the server in response to eroneous client
    # behavior. Can be overridden in subclasses of the AutomatonServer.
    self.Exceptions = Exceptions
    # A dictionary mapping serviceids to registered scripts
    self.registeredServices = {}
    # Update __init__.py in the Automaton package when a new script is added
    self.commandPackages = {}
    self.loadedScripts = set()
    for script in Automaton.__all__:
      try:
        if self.__getPlatform() in globals()[script].platform():
          try:
            cmd = __import__('Automaton.%s' % script, globals(), locals(), [script])
            self.commandPackages[script] = cmd
            self.loadedScripts.add(script)
          # If there is a problem importing the 
          except (Exceptions.ModuleLoadError, ImportError):
            print "Error loading module %s" % script
      # If no platform is provided, add the script anyways for
      # compatibility with unknown platforms, etc
      except (AttributeError, TypeError):
        try:
          cmd = __import__('Automaton.%s' % script, globals(), locals(), [script])
          self.commandPackages[script] = cmd
          self.loadedScripts.add(script)
        except (Exceptions.ModuleLoadException, ImportError):
          print "Error loading module %s" % script

  # Registers a client service with the server. Calculates a UUID that will
  # identify which scripts are loaded for each client service
  # Arguments: none
  # Return value: string
  # Throws: none
  def registerService(self):
    id = str(uuid.uuid1())
    while self.registeredServices.has_key(id):
      print id
      id = str(uuid.uuid1())
    logger.log("Registering service %s" % id)
    self.registeredServices[id]=set()
    return id

  # Unregisters a client service from the server. Any further use of its serviceid will
  # result in a ServiceNotRegisteredException
  # Arguments: serviceid:string - id associated with a registered service
  # Return value: void
  # Throws: ServiceNotRegisteredException
  def unregisterService(self, serviceid):
    if serviceid not in self.registeredServices:
      raise self.Exceptions.ServiceNotRegisteredException()

    logger.log("Unregistering service %s" % serviceid)
    del self.registeredServices[serviceid]
    return

  # Registers a script for use by a client service.
  # Arguments: serviceid:string, scriptname:string
  # Return value: void
  # Throws: ServiceNotRegisteredException, ScriptNotLoadedException
  def registerScript(self, serviceid, scriptname):
    if serviceid not in self.registeredServices:
      raise self.Exceptions.ServiceNotRegisteredException()
    if scriptname not in self.loadedScripts:
      raise self.Exceptions.ScriptNotLoadedException(scriptname)

    if scriptname not in self.registeredServices[serviceid]:
      logger.log("Adding script %s for service %s" % (scriptname, serviceid))
      self.registeredServices[serviceid].add(scriptname)
    return

  # Unregisters a script from a client service.
  # Arguments: serviceid:string, scriptname:string
  # Return value: void
  # Throws: ServiceNotRegisteredException, ScriptNotLoadedException
  def unregisterScript(self, serviceid, scriptname):
    if serviceid not in self.registeredServices:
      raise self.Exceptions.ServiceNotRegisteredException()
    if scriptname not in self.registeredServices[serviceid]:
      raise self.Exceptions.ScriptNotRegisteredException(scriptname)

    logger.log("Removing script %s for service %s" % (scriptname, serviceid))
    self.registeredServices[serviceid].remove(scriptname)
    return

  # Executes the provided script with any associated arguments.
  # Arguments: serviceid:string, scriptname:string, arguments:string
  # Return value: string
  # Throws: ServiceNotRegisteredException, ScriptNotRegisteredException
  def execute(self, serviceid, scriptname, arguments):
    if serviceid not in self.registeredServices:
      raise self.Exceptions.ServiceNotRegisteredException()
    if scriptname not in self.registeredServices[serviceid]:
      raise self.Exceptions.ScriptNotRegisteredException(scriptname)

    # Executes module from the pool of globally imported modules.
    # Safe because only legal scripts are allowed to be registered.
    return self.commandPackages[scriptname].execute(arguments)

  # Uses the interpreter to translate the raw (arbitrary) text into
  # a command:arguments pair that is then executed like normal
  # Arguments: serviceid:string, raw:string
  # Return value: string
  # Throws: ServiceNotRegisteredException, ScriptNotRegisteredException,
  #         UnknownActionException
  def interpret(self, serviceid, raw):
    if serviceid not in self.registeredServices:
      raise self.Exceptions.ServiceNotRegisteredException()
    command, args = Interpreter.interpret(raw, self.registeredServices[serviceid])
    return self.execute(serviceid, command, args)

  # Tests if the specified script is loaded or not.
  # Querying is possible even when unregistered
  # Arguments: scriptname:string
  # Return value: bool
  # Throws: none
  def isScript(self, scriptname):
    return scriptname in self.loadedScripts

  # Returns a set of strings containing all loaded scripts
  # Querying is possible even when unregistered
  # Arguments: none
  # Return value: set<string>
  # Throws: none
  def getAvailableScripts(self):
    return self.loadedScripts

  # Returns the contents of the specified script's help() method
  # Replaces the complicated help "command"
  # Arguments: scriptname:string
  # Return value: string
  # Throws ScriptNotLoadedException
  def scriptUsage(self, scriptname):
    if scriptname not in self.loadedScripts:
      raise self.Exceptions.ScriptNotLoadedException(scriptname)
    return globals()[scriptname].help()

  def __getPlatform():
    if platform.system().lowercase().startswith('windows'):
      return 'windows'
    elif platform.system().lowercase().startswith('darwin'):
      return 'mac'
    else:
      return 'linux'

