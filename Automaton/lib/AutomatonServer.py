#!/usr/bin/env python

import sys
import uuid
import utils
import logger
import platform
import threading
import Automaton
import Exceptions
import StatusIcon
import Interpreter
import platformdata
import InputSanitizer

class AutomatonServer:
  def __init__(self, withgui = False):

    self.needsgui = withgui

    # The exceptions generated by the server in response to eroneous client
    # behavior. Can be overridden in subclasses of the AutomatonServer.
    self.Exceptions = Exceptions

    # Set up the sanitizer and allow it to "call" any command that we've loaded
    self.sanitizer = InputSanitizer.InputSanitizer()
    self.sanitizer.call = self.call

    # A dictionary mapping serviceids to registered scripts
    self.registeredServices = {}

    # Update __init__.py in the Automaton package when a new script is added
    self.loadedScripts = {}

    for script in Automaton.__all__:
      try:
        # Imports the command module
        cmd = __import__('Automaton.%s' % script, fromlist= [script])
        self.load_script_module(cmd)
      except Exception, e:
        logger.log("Error loading module %s." % script, e)

    self.interpreter = Interpreter.Interpreter(self.loadedScripts.values())

  def load_script_module(self, module):
    script = utils.get_module_name(module.__name__)
    # Extracts the class from the command module
    # Class must have same name as module
    cmdcls = getattr(module, script)()
    # Lets commands call other commands
    cmdcls.call = self.call
    # Either no platform restriction is provided, or the platform is
    # in the restriction set
    if not hasattr(cmdcls, 'platform') or (platformdata.platform in
                                                         cmdcls.platform()):
      if script in self.loadedScripts:
        self.loadedScripts[script] = (cmdcls, self.loadedScripts[script][1])
      else:
        self.loadedScripts[script] = (cmdcls, threading.Lock())

  def reload_script(self, script):
    if script in self.loadedScripts:
      self.loadedScripts[script][1].acquire()
      try:
        cmd = reload(__import__('Automaton.%s' % script, fromlist = [script]))
        self.load_script_module(cmd)
        logger.log("Script %s has been successfully reloaded." % script)
      except Exception, e:
        print e
        self.loadedScripts[script] = (None, self.loadedScripts[script][1])
        s = "Exception encountered reloading %s. Script disabled." % script
        logger.log(s)
      finally:
        self.loadedScripts[script][1].release()

  # Registers a client service with the server. Calculates a UUID that will
  # identify which scripts are loaded for each client service
  # Arguments: none
  # Return value: string
  # Throws: none
  def registerService(self):
    id = str(uuid.uuid1())
    while self.registeredServices.has_key(id):
      id = str(uuid.uuid1())
    logger.log("Registering service %s" % id)
    self.registeredServices[id]=set()
    return id

  # Unregisters a client service from the server. Any further use of its serviceid will
  # result in a ServiceNotRegisteredException
  # Arguments: serviceid:string - id associated with a registered service
  # Return value: void
  # Throws: ServiceNotRegisteredException
  def unregisterService(self, serviceid):
    if serviceid not in self.registeredServices:
      raise self.Exceptions.ServiceNotRegisteredException()

    logger.log("Unregistering service %s" % serviceid)
    del self.registeredServices[serviceid]
    return

  # Registers a script for use by a client service.
  # Arguments: serviceid:string, scriptname:string
  # Return value: void
  # Throws: ServiceNotRegisteredException, ScriptNotLoadedException
  def registerScript(self, serviceid, scriptname):
    if serviceid not in self.registeredServices:
      raise self.Exceptions.ServiceNotRegisteredException()
    if scriptname not in self.loadedScripts.keys():
      raise self.Exceptions.ScriptNotLoadedException(scriptname)

    if scriptname not in self.registeredServices[serviceid]:
      logger.log("Adding script %s for service %s" % (scriptname, serviceid))
      self.registeredServices[serviceid].add(scriptname)
    return

  # Unregisters a script from a client service.
  # Arguments: serviceid:string, scriptname:string
  # Return value: void
  # Throws: ServiceNotRegisteredException, ScriptNotRegisteredException
  def unregisterScript(self, serviceid, scriptname):
    if serviceid not in self.registeredServices:
      raise self.Exceptions.ServiceNotRegisteredException()
    if scriptname not in self.registeredServices[serviceid]:
      raise self.Exceptions.ScriptNotRegisteredException(scriptname)

    logger.log("Removing script %s for service %s" % (scriptname, serviceid))
    self.registeredServices[serviceid].remove(scriptname)
    return

  # Backend "execution" code - no service id is necessary because
  # it can only be called from scripts
  def call(self, scriptname, arguments):
    if scriptname not in self.loadedScripts:
      raise self.Exceptions.ScriptNotLoadedException(scriptname)

    # Executes module from the pool of globally imported modules.
    # Safe because only legal scripts are allowed to be registered.
    self.loadedScripts[scriptname][1].acquire()
    try:
      if self.loadedScripts[scriptname][0] is None:
        return "Script is currently unavailable. Please fix script and reload."
      arguments = self.sanitizer.sanitize(arguments)
      try:
        retval = self.loadedScripts[scriptname][0].execute(arguments)
      finally:
        self.loadedScripts[scriptname][1].release()
    except Exception, e:
      retval = "Exception encountered executing script %s." % scriptname
      logger.log("%s\n%s" % (retval, e))
    self.sanitizer.set_prev(retval)
    return retval.strip()

  # Executes the provided script with any associated arguments.
  # Arguments: serviceid:string, scriptname:string, arguments:string
  # Return value: string
  # Throws: ServiceNotRegisteredException, ScriptNotRegisteredException
  def execute(self, serviceid, scriptname, arguments):
    if serviceid not in self.registeredServices:
      raise self.Exceptions.ServiceNotRegisteredException()
    if scriptname not in self.registeredServices[serviceid]:
      raise self.Exceptions.ScriptNotRegisteredException(scriptname)

    return self.call(scriptname, arguments)

  # Uses the interpreter to translate the raw (arbitrary) text into
  # a command:arguments pair that is then executed like normal
  # Arguments: serviceid:string, raw:string
  # Return value: string
  # Throws: ServiceNotRegisteredException, ScriptNotRegisteredException,
  #         UnknownActionException
  def interpret(self, serviceid, raw):
    if serviceid not in self.registeredServices:
      raise self.Exceptions.ServiceNotRegisteredException()
    command, args = self.interpreter.interpret(raw)
    return self.execute(serviceid, command, args)

  # Tests if the specified script is loaded or not.
  # Querying is possible even when unregistered
  # Arguments: scriptname:string
  # Return value: bool
  # Throws: none
  def isScript(self, scriptname):
    return scriptname in self.loadedScripts.keys()

  # Returns a set of strings containing all loaded scripts
  # Querying is possible even when unregistered
  # Arguments: none
  # Return value: set<string>
  # Throws: none
  def getAvailableScripts(self):
    return self.loadedScripts.keys()

  # Returns the contents of the specified script's help() method
  # Replaces the complicated help "command"
  # Arguments: scriptname:string
  # Return value: string
  # Throws ScriptNotLoadedException
  def scriptUsage(self, scriptname):
    if scriptname not in self.loadedScripts.keys():
      raise self.Exceptions.ScriptNotLoadedException(scriptname)
    return self.loadedScripts[scriptname][0].help()

  # No initialization done for the local server, can be overridden in subclasses
  def initialize(self):
    pass

  # Ensures that any networking is done in a separate thread from 
  def start(self):
    if hasattr(self, "start_local"):
      # Spawn a second thread for the start_local method
      if self.needsgui:
        thread = threading.Thread(target = self.start_local)
        thread.setDaemon(True)
        thread.start()
        self.load_gui()
      else:
        self.start_local()
    # If there's no start_local method defined, we've got to load the gui
    # or else there will be no way to communicate with the application.
    else:
      self.load_gui()

  def load_gui(self):
    try:
      import gtk
    except ImportError:
      print ("gtk toolkit not present, so no graphical user interface will be "
             "available.")
      return
    gtk.gdk.threads_init()
    StatusIcon.StatusIcon(self)
    gtk.main()
