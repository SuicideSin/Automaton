#!/usr/bin/env python

import sys
import uuid
import utils
import logger
import platform
import threading
import Exceptions
import StatusIcon
import Interpreter
import platformdata
import InputSanitizer
import Automaton.plugins

class AutomatonServer:

  def __init__(self, withgui = False):

    self.needsgui = withgui

    # The exceptions generated by the server in response to erroneous client
    # behavior. Can be overridden in subclasses of the AutomatonServer.
    self.Exceptions = Exceptions

    # Set up the sanitizer and allow it to "call" any plugin that we've loaded
    self.sanitizer = InputSanitizer.InputSanitizer()
    self.sanitizer.call = self.call

    # A dictionary mapping serviceids to registered scripts
    self.registeredServices = {}

    # Update __init__.py in the Automaton package when a new plugin is added
    self.loadedPlugins = {}

    for script in Automaton.plugins.__all__:
      try:
        self.enablePlugin(script)
      except Exception, e:
        logger.log("Error loading module %s." % script, e)

    self.interpreter = Interpreter.Interpreter(self.loadedPlugins.values())

  def enablePlugin(self, plugin):
    # Imports the plugin module
    cmd = __import__('Automaton.plugins.%s' % plugin, fromlist= [plugin])
    # Extracts the class from the plugin module
    # Class must have same name as module
    cmdcls = getattr(cmd, plugin)()
    # Lets plugins call other plugins
    cmdcls.call = self.call
    # Either no platform restriction is provided, or the platform is
    # in the restriction set
    if not hasattr(cmdcls, 'platform') or (platformdata.platform in
                                                         cmdcls.platform()):
      # Plugin, lock tuple
      self.loadedPlugins[plugin] = (cmdcls, threading.Lock())

  def disableScript(self, plugin):
    del self.loadedPlugins[plugin]

  def reloadScript(self, plugin):
    if plugin in self.loadedPlugins:
      self.loadedPlugins[plugin][1].acquire()
      try:
        cmd = reload(__import__('Automaton.plugins.%s' % plugin, fromlist = [plugin]))
        self.loadedPlugins[plugin] = (cmdcls, self.loadedPlugins[plugin][1])
        logger.log("Plugin %s has been successfully reloaded." % plugin)
      except Exception, e:
        print e
        self.loadedPlugins[plugin] = (None, self.loadedPlugins[plugin][1])
        s = "Exception encountered reloading %s. Plugin disabled." % plugin
        logger.log(s)
      finally:
        self.loadedPlugins[plugin][1].release()

  # Registers a client service with the server. Calculates a UUID that will
  # identify which plugins are loaded for each client service
  # Arguments: none
  # Return value: string
  # Throws: none
  def registerService(self):
    id = str(uuid.uuid1())
    while self.registeredServices.has_key(id):
      id = str(uuid.uuid1())
    logger.log("Registering service %s" % id)
    self.registeredServices[id]=set()
    return id

  # Unregisters a client service from the server. Any further use of its serviceid will
  # result in a ServiceNotRegisteredException
  # Arguments: serviceid:string - id associated with a registered service
  # Return value: void
  # Throws: ServiceNotRegisteredException
  def unregisterService(self, serviceid):
    if serviceid not in self.registeredServices:
      raise self.Exceptions.ServiceNotRegisteredException()

    logger.log("Unregistering service %s" % serviceid)
    del self.registeredServices[serviceid]
    return

  # Registers a plugin for use by a client service.
  # Arguments: serviceid:string, scriptname:string
  # Return value: void
  # Throws: ServiceNotRegisteredException, ScriptNotLoadedException
  def registerScript(self, serviceid, scriptname):
    if serviceid not in self.registeredServices:
      raise self.Exceptions.ServiceNotRegisteredException()
    if scriptname not in self.loadedPlugins.keys():
      raise self.Exceptions.ScriptNotLoadedException(scriptname)

    if scriptname not in self.registeredServices[serviceid]:
      logger.log("Adding plugin %s for service %s" % (scriptname, serviceid))
      self.registeredServices[serviceid].add(scriptname)
    return

  # Unregisters a plugin from a client service.
  # Arguments: serviceid:string, scriptname:string
  # Return value: void
  # Throws: ServiceNotRegisteredException, ScriptNotRegisteredException
  def unregisterScript(self, serviceid, scriptname):
    if serviceid not in self.registeredServices:
      raise self.Exceptions.ServiceNotRegisteredException()
    if scriptname not in self.registeredServices[serviceid]:
      raise self.Exceptions.ScriptNotRegisteredException(scriptname)

    logger.log("Removing script %s for service %s" % (scriptname, serviceid))
    self.registeredServices[serviceid].remove(scriptname)
    return

  # Backend "execution" code - no service id is necessary because
  # it can only be called from scripts
  def call(self, scriptname, arguments):
    if scriptname not in self.loadedPlugins:
      raise self.Exceptions.ScriptNotLoadedException(scriptname)

    # Executes module from the pool of globally imported modules.
    # Safe because only legal scripts are allowed to be registered.
    self.loadedPlugins[scriptname][1].acquire()
    try:
      if self.loadedPlugins[scriptname][0] is None:
        return "Plugin is currently unavailable. Please fix plugin and reload."
      arguments = self.sanitizer.sanitize(arguments)
      try:
        retval = self.loadedPlugins[scriptname][0].execute(arguments)
      finally:
        self.loadedPlugins[scriptname][1].release()
    except Exception, e:
      retval = "Exception encountered executing plugin %s." % scriptname
      logger.log("%s\n%s" % (retval, e))
    self.sanitizer.set_prev(retval)
    return retval.strip()

  # Executes the provided plugin with any associated arguments.
  # Arguments: serviceid:string, scriptname:string, arguments:string
  # Return value: string
  # Throws: ServiceNotRegisteredException, ScriptNotRegisteredException
  def execute(self, serviceid, scriptname, arguments):
    if serviceid not in self.registeredServices:
      raise self.Exceptions.ServiceNotRegisteredException()
    if scriptname not in self.registeredServices[serviceid]:
      raise self.Exceptions.ScriptNotRegisteredException(scriptname)

    return self.call(scriptname, arguments)

  # Uses the interpreter to translate the raw (arbitrary) text into
  # a command:arguments pair that is then executed like normal
  # Arguments: serviceid:string, raw:string
  # Return value: string
  # Throws: ServiceNotRegisteredException, ScriptNotRegisteredException,
  #         UnknownActionException
  def interpret(self, serviceid, raw):
    if serviceid not in self.registeredServices:
      raise self.Exceptions.ServiceNotRegisteredException()
    command, args = self.interpreter.interpret(raw)
    return self.execute(serviceid, command, args)

  # Tests if the specified plugin is loaded or not.
  # Querying is possible even when unregistered
  # Arguments: scriptname:string
  # Return value: bool
  # Throws: none
  def isScript(self, scriptname):
    return scriptname in self.loadedPlugins.keys()

  # Returns a set of strings containing all loaded plugins
  # Querying is possible even when unregistered
  # Arguments: none
  # Return value: set<string>
  # Throws: none
  def getAvailableScripts(self):
    return self.loadedPlugins.keys()

  # Returns the contents of the specified plugin's help() method
  # Replaces the complicated help "command"
  # Arguments: scriptname:string
  # Return value: string
  # Throws ScriptNotLoadedException
  def scriptUsage(self, scriptname):
    if scriptname not in self.loadedPlugins.keys():
      raise self.Exceptions.ScriptNotLoadedException(scriptname)
    return self.loadedPlugins[scriptname][0].help()

  # No initialization done for the local server, can be overridden in subclasses
  def initialize(self):
    pass

  # Ensures that any networking is done in a separate thread from 
  def start(self):
    if hasattr(self, "_start"):
      # Spawn a second thread for the _start method
      if self.needsgui:
        thread = threading.Thread(target = self._start)
        thread.setDaemon(True)
        thread.start()
        self.load_gui()
      else:
        self._start()
    # If there's no _start method defined, we've got to load the gui
    # or else there will be no way to communicate with the application.
    else:
      self.load_gui()

  def load_gui(self):
    try:
      import gtk
    except ImportError:
      print ("gtk toolkit not present, so no graphical user interface will be "
             "available.")
      return
    StatusIcon.StatusIcon(self)
    gtk.gdk.threads_init()
    gtk.main()
